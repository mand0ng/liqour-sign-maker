import { writeFile, readFile, unlink } from 'fs/promises';
import { join } from 'path';
import { NextResponse } from 'next/server';

export async function POST(req) {
    try {
        const { name } = await req.json();

        // 1. Validation: Prevent deleting defaults
        const defaults = ['Light', 'Dark', 'Gin Prompt', 'Funda Test'];
        if (defaults.includes(name)) {
            return NextResponse.json({ error: "Cannot delete default templates" }, { status: 400 });
        }

        const safeName = name.replace(/[^a-zA-Z0-9]/g, '');
        const templatesDir = join(process.cwd(), 'components', 'templates');
        const fileName = `${safeName}.jsx`;

        // 2. Delete the component file
        try {
            await unlink(join(templatesDir, fileName));
        } catch (err) {
            console.warn(`File ${fileName} not found or already deleted.`);
        }

        // 3. Update index.js
        const indexFile = join(templatesDir, 'index.js');
        let indexContent = await readFile(indexFile, 'utf8');

        // Remove Import
        // Matches: import safeName from './safeName'; (and variations like newlines)
        const importRegex = new RegExp(`import\\s+${safeName}\\s+from\\s+['"]\\./${safeName}['"];?\\n?`, 'g');
        indexContent = indexContent.replace(importRegex, '');

        // Remove from Export dictionary
        // Matches: 'safeName': safeName, (with surrounding whitespace)
        // Note: The key in the object map might be exactly 'name' (e.g. 'test1') if it has no spaces, or matched safeName.
        // We know from save-template that the key uses `safeName` if generated by AI, 
        // BUT the user might use the UI key which is just `name`.
        // In index.js we see keys like 'test1': test1. 
        // The key is the quoted string, value is the variable name.

        // Regex to find line: 'KeyName': VariableName,
        const exportRegex = new RegExp(`\\s*['"]${name}['"]:\\s*${safeName},?\\n?`, 'g');
        indexContent = indexContent.replace(exportRegex, '\n');

        // Clean up empty lines if any double newlines were created
        indexContent = indexContent.replace(/\n\s*\n/g, '\n');

        await writeFile(indexFile, indexContent);

        return NextResponse.json({ success: true });
    } catch (error) {
        console.error("Delete Template Error:", error);
        return NextResponse.json({ error: error.message }, { status: 500 });
    }
}
